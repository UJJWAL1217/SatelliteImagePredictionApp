# -*- coding: utf-8 -*-
"""SatelliteImageDetection2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cRZXUSwd19r1SmSdauBxsPio9y0Td8v2
"""

!pip install split-folders

#Importing Libraries

from keras.preprocessing.image import ImageDataGenerator
from keras.layers import Conv2D, MaxPooling2D, Dense, Flatten, Activation
from keras import models
from keras.applications.vgg16 import VGG16
from keras.utils import plot_model
from PIL import Image
import splitfolders

#Spliting Data In Train , Test , Validation
input_folder = "/content/drive/MyDrive/data"
output = "dataset"

splitfolders.ratio(input_folder, output=output, seed=42, ratio=(0.7,0.2,0.1))

#Data Argumentation
train_datagen = ImageDataGenerator(rescale = 1./255,
                                   shear_range = 0.2,
                                   zoom_range = 0.2,
                                   horizontal_flip = True)
training_set = train_datagen.flow_from_directory('/content/dataset/train',
                                                 target_size = (224, 224),
                                                 batch_size = 32,
                                                 class_mode = 'categorical')

test_datagen = ImageDataGenerator(rescale = 1./255)
test_set = test_datagen.flow_from_directory('/content/dataset/test',
                                            target_size = (224, 224),
                                            batch_size = 32,
                                            class_mode = 'categorical')

val_datagen = ImageDataGenerator(rescale = 1./255)
val_set = val_datagen.flow_from_directory('/content/dataset/val',
                                            target_size = (224, 224),
                                            batch_size = 32,
                                            class_mode = 'categorical')

training_set.class_indices

#Creating Base Model With VGG16Â¶
base_model = VGG16(weights="imagenet", include_top=False, input_shape=(224,224,3))
base_model.trainable = False

# Adding Layers to VGG16
flatten_layer = Flatten()
dense_layer_1 = Dense(50, activation='relu')
dense_layer_2 = Dense(20, activation='relu')
prediction_layer = Dense(4, activation='softmax')

# Creating Final Model
model = models.Sequential([
    base_model,
    flatten_layer,
    dense_layer_1,
    dense_layer_2,
    prediction_layer
])

model.compile(
    optimizer='adam',
    loss='categorical_crossentropy',
    metrics=['accuracy'],
)

# Training Model With Training And Test data
history = model.fit(x = training_set, validation_data = test_set, epochs = 1)

_,acc = model.evaluate(val_set,verbose = 1)
print('>%.3f'%(acc*100))

model.save('best_model.h5')

import tensorflow as tfz
from keras.preprocessing import image
from keras.models import load_model
from keras.applications.mobilenet_v2 import preprocess_input, decode_predictions
import numpy as np

# Load your pre-trained CNN model
model = load_model('best_model.h5')  # Replace with the path to your saved model

# Load and preprocess the image
img_path = '/content/download.jpg'  # Replace with the path to your image
img = image.load_img(img_path, target_size=(224, 224))  # Adjust target_size based on your model architecture
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)
img_array = preprocess_input(img_array)

# Make predictions
predictions = model.predict(img_array)

# Get the class index with the highest probability
predicted_class_index = np.argmax(predictions)

# Print the predicted class index
print(f"Predicted class index: {predicted_class_index}")

